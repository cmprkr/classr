// prisma/schema.prisma
datasource db {
  provider = "sqlite" // or "postgresql" if you already use PG
  url = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id String @id @default(cuid())
  name String?
  username String? @unique
  email String? @unique
  emailVerified DateTime?
  image String?
  passwordHash String?
  classes Class[]
  chats ChatMessage[]
  lectures Lecture[]
  accounts Account[]
  sessions Session[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id String @id @default(cuid())
  userId String
  type String
  provider String
  providerAccountId String
  refresh_token String?
  access_token String?
  expires_at Int?
  token_type String?
  scope String?
  id_token String?
  session_state String?
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([provider, providerAccountId])
}

model Session {
  id String @id @default(cuid())
  sessionToken String @unique
  userId String
  expires DateTime
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token String @unique
  expires DateTime
  @@unique([identifier, token])
}

model Class {
  id String @id @default(cuid())
  name String
  userId String
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  lectures Lecture[]
  chats ChatMessage[]
  chunks Chunk[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  syncEnabled Boolean @default(false)
  syncKey String?
}

enum ResourceType {
  LECTURE
  SLIDESHOW
  NOTES
  HANDOUT
  GRADED_ASSIGNMENT
  UNGRADED_ASSIGNMENT
  GRADED_TEST
  OTHER
}

model Lecture {
  id String @id @default(cuid())
  classId String
  clazz Class @relation(fields: [classId], references: [id], onDelete: Cascade)
  userId String?
  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)
  kind ResourceType @default(LECTURE)
  descriptor String?
  mime String?
  textContent String?
  originalName String
  filePath String?
  status String @default("PROCESSING")
  durationSec Int?
  transcript String?
  segmentsJson String?
  summaryJson String?
  chunks Chunk[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  syncKey String?
  includeInMemory Boolean @default(true)
  includeInMemoryUser Json?
  @@index([syncKey])
  @@index([createdAt])
}

model Chunk {
  id String @id @default(cuid())
  classId String
  lectureId String
  source String
  startSec Int
  endSec Int
  text String
  vectorJson String
  createdAt DateTime @default(now())
  clazz Class @relation(fields: [classId], references: [id], onDelete: Cascade)
  lecture Lecture @relation(fields: [lectureId], references: [id], onDelete: Cascade)
}

model ChatMessage {
  id String @id @default(cuid())
  classId String
  userId String
  role String
  content String
  citations String?
  createdAt DateTime @default(now())
  clazz Class @relation(fields: [classId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}